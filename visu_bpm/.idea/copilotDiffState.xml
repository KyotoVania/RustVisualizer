<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.rs" />
              <option name="originalContent" value="use anyhow::{Context, Result};&#10;use clap::Parser;&#10;use hound::{SampleFormat, WavReader};&#10;use num_complex::Complex;&#10;use rubato::{FftFixedIn, Resampler};&#10;use rustfft::FftPlanner;&#10;use std::path::PathBuf;&#10;&#10;/// Programme de détection de BPM utilisant l'autocorrélation et le flux spectral médian&#10;#[derive(Parser, Debug)]&#10;#[command(author, version, about, long_about = None)]&#10;struct Args {&#10;    /// Chemin vers le fichier WAV à analyser&#10;    #[arg()]&#10;    file_path: PathBuf,&#10;&#10;    /// BPM minimum à rechercher&#10;    #[arg(long, default_value_t = 60.0)]&#10;    min_bpm: f32,&#10;&#10;    /// BPM maximum à rechercher&#10;    #[arg(long, default_value_t = 180.0)]&#10;    max_bpm: f32,&#10;}&#10;&#10;// ====================&#10;// Module Decoder&#10;// ====================&#10;mod decoder {&#10;    use super::*;&#10;&#10;    /// Charge et décode un fichier WAV en mono avec rééchantillonnage à 44100 Hz&#10;    pub fn decode_to_mono(path: &amp;PathBuf, target_sr: u32) -&gt; Result&lt;Vec&lt;f32&gt;&gt; {&#10;        let mut reader = WavReader::open(path)&#10;            .with_context(|| format!(&quot;Impossible d'ouvrir le fichier {:?}&quot;, path))?;&#10;&#10;        let spec = reader.spec();&#10;        let channels = spec.channels as usize;&#10;        let source_sr = spec.sample_rate;&#10;&#10;        // Lecture des échantillons&#10;        let samples: Vec&lt;f32&gt; = match spec.sample_format {&#10;            SampleFormat::Float =&gt; {&#10;                reader.samples::&lt;f32&gt;()&#10;                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()&#10;                    .context(&quot;Erreur lors de la lecture des échantillons&quot;)?&#10;            }&#10;            SampleFormat::Int =&gt; {&#10;                let bit_depth = spec.bits_per_sample;&#10;                let max_val = (1 &lt;&lt; (bit_depth - 1)) as f32;&#10;                reader.samples::&lt;i32&gt;()&#10;                    .map(|s| s.map(|v| v as f32 / max_val))&#10;                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()&#10;                    .context(&quot;Erreur lors de la conversion des échantillons&quot;)?&#10;            }&#10;        };&#10;&#10;        // Conversion en mono&#10;        let mono_samples: Vec&lt;f32&gt; = if channels &gt; 1 {&#10;            samples.chunks(channels)&#10;                .map(|frame| frame.iter().sum::&lt;f32&gt;() / channels as f32)&#10;                .collect()&#10;        } else {&#10;            samples&#10;        };&#10;&#10;        // Rééchantillonnage si nécessaire&#10;        if source_sr != target_sr {&#10;            resample(&amp;mono_samples, source_sr, target_sr)&#10;        } else {&#10;            Ok(mono_samples)&#10;        }&#10;    }&#10;&#10;    /// Rééchantillonne le signal audio à la fréquence cible&#10;    fn resample(samples: &amp;[f32], source_sr: u32, target_sr: u32) -&gt; Result&lt;Vec&lt;f32&gt;&gt; {&#10;        let mut resampler = FftFixedIn::&lt;f32&gt;::new(&#10;            source_sr as usize,&#10;            target_sr as usize,&#10;            1024,&#10;            1,&#10;            1,&#10;        ).context(&quot;Erreur lors de l'initialisation du resampler&quot;)?;&#10;&#10;        let mut output = vec![vec![0.0f32; resampler.output_frames_max()]; 1];&#10;        let mut resampled = Vec::new();&#10;&#10;        // Traitement par chunks&#10;        for chunk in samples.chunks(1024) {&#10;            let input = vec![chunk.to_vec()];&#10;            let (_, out_len) = resampler.process_into_buffer(&amp;input, &amp;mut output, None)&#10;                .context(&quot;Erreur lors du rééchantillonnage&quot;)?;&#10;            resampled.extend_from_slice(&amp;output[0][..out_len]);&#10;        }&#10;&#10;        Ok(resampled)&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module ODF (Onset Detection Function)&#10;// ====================&#10;mod odf {&#10;    use super::*;&#10;&#10;    /// Paramètres pour la génération de l'ODF&#10;    pub struct OdfGenerator {&#10;        pub frame_size: usize,&#10;        pub hop_size: usize,&#10;    }&#10;&#10;    impl OdfGenerator {&#10;        pub fn new(frame_size: usize, hop_size: usize) -&gt; Self {&#10;            Self { frame_size, hop_size }&#10;        }&#10;&#10;        /// Génère l'ODF en utilisant le flux spectral agrégé par la médiane&#10;        pub fn generate(&amp;self, samples: &amp;[f32]) -&gt; Vec&lt;f32&gt; {&#10;            let mut planner = FftPlanner::&lt;f32&gt;::new();&#10;            let fft = planner.plan_fft_forward(self.frame_size);&#10;&#10;            // Création de la fenêtre de Hann manuellement&#10;            let window: Vec&lt;f32&gt; = (0..self.frame_size)&#10;                .map(|i| {&#10;                    let t = i as f32 / (self.frame_size - 1) as f32;&#10;                    0.5 * (1.0 - (2.0 * std::f32::consts::PI * t).cos())&#10;                })&#10;                .collect();&#10;&#10;            let mut odf = Vec::new();&#10;            let mut prev_magnitudes = vec![0.0; self.frame_size / 2 + 1];&#10;&#10;            // Calcul du nombre de frames&#10;            let num_frames = (samples.len() - self.frame_size) / self.hop_size + 1;&#10;&#10;            for frame_idx in 0..num_frames {&#10;                let start = frame_idx * self.hop_size;&#10;                let end = start + self.frame_size;&#10;&#10;                if end &gt; samples.len() {&#10;                    break;&#10;                }&#10;&#10;                // Application de la fenêtre et préparation pour FFT&#10;                let mut buffer: Vec&lt;Complex&lt;f32&gt;&gt; = samples[start..end]&#10;                    .iter()&#10;                    .zip(window.iter())&#10;                    .map(|(s, w)| Complex::new(s * w, 0.0))&#10;                    .collect();&#10;&#10;                // FFT&#10;                fft.process(&amp;mut buffer);&#10;&#10;                // Calcul des magnitudes (seulement la moitié positive du spectre)&#10;                let magnitudes: Vec&lt;f32&gt; = buffer[..self.frame_size / 2 + 1]&#10;                    .iter()&#10;                    .map(|c| (c.re * c.re + c.im * c.im).sqrt())&#10;                    .collect();&#10;&#10;                // Calcul du flux spectral avec agrégation par médiane&#10;                let mut spectral_diffs: Vec&lt;f32&gt; = magnitudes&#10;                    .iter()&#10;                    .zip(prev_magnitudes.iter())&#10;                    .map(|(current, prev)| {&#10;                        // Passage en échelle logarithmique pour plus de robustesse&#10;                        let log_current = (current + 1e-10).ln();&#10;                        let log_prev = (prev + 1e-10).ln();&#10;                        (log_current - log_prev).max(0.0)  // Redressement demi-onde&#10;                    })&#10;                    .collect();&#10;&#10;                // Calcul de la médiane&#10;                if !spectral_diffs.is_empty() {&#10;                    spectral_diffs.sort_by(|a, b| a.partial_cmp(b).unwrap());&#10;                    let median_idx = spectral_diffs.len() / 2;&#10;                    odf.push(spectral_diffs[median_idx]);&#10;                } else {&#10;                    odf.push(0.0);&#10;                }&#10;&#10;                prev_magnitudes = magnitudes;&#10;            }&#10;&#10;            odf&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module ACF (Autocorrelation Function)&#10;// ====================&#10;mod acf {&#10;    use super::*;&#10;&#10;    /// Analyseur d'autocorrélation utilisant le théorème de Wiener-Khinchin&#10;    pub struct AcfAnalyzer {&#10;        pub window_size: usize,&#10;    }&#10;&#10;    impl AcfAnalyzer {&#10;        pub fn new(window_size: usize) -&gt; Self {&#10;            Self { window_size }&#10;        }&#10;&#10;        /// Calcule l'autocorrélation à court terme via FFT (Wiener-Khinchin)&#10;        pub fn analyze(&amp;self, odf_buffer: &amp;[f32]) -&gt; Vec&lt;f32&gt; {&#10;            // Prendre les dernières valeurs selon la taille de fenêtre&#10;            let start = odf_buffer.len().saturating_sub(self.window_size);&#10;            let window = &amp;odf_buffer[start..];&#10;&#10;            // Zero-padding pour obtenir une corrélation linéaire correcte&#10;            let fft_len = (window.len() * 2).next_power_of_two();&#10;&#10;            let mut planner = FftPlanner::&lt;f32&gt;::new();&#10;            let fft = planner.plan_fft_forward(fft_len);&#10;            let ifft = planner.plan_fft_inverse(fft_len);&#10;&#10;            // Préparation du buffer avec zero-padding&#10;            let mut buffer: Vec&lt;Complex&lt;f32&gt;&gt; = window&#10;                .iter()&#10;                .map(|&amp;s| Complex::new(s, 0.0))&#10;                .chain(std::iter::repeat(Complex::new(0.0, 0.0)))&#10;                .take(fft_len)&#10;                .collect();&#10;&#10;            // 1. Forward FFT&#10;            fft.process(&amp;mut buffer);&#10;&#10;            // 2. Power spectrum (|X(f)|²)&#10;            for c in buffer.iter_mut() {&#10;                let power = c.re * c.re + c.im * c.im;&#10;                *c = Complex::new(power, 0.0);&#10;            }&#10;&#10;            // 3. Inverse FFT&#10;            ifft.process(&amp;mut buffer);&#10;&#10;            // 4. Normalisation et extraction de la partie réelle&#10;            let scale = 1.0 / fft_len as f32;&#10;            buffer.iter()&#10;                .map(|c| c.re * scale)&#10;                .take(window.len())  // Ne garder que la partie utile&#10;                .collect()&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module Estimator&#10;// ====================&#10;mod estimator {&#10;    /// Estimateur de BPM avec stabilisation&#10;    pub struct BpmEstimator {&#10;        pub min_bpm: f32,&#10;        pub max_bpm: f32,&#10;        pub history: Vec&lt;f32&gt;,&#10;        pub history_size: usize,&#10;    }&#10;&#10;    impl BpmEstimator {&#10;        pub fn new(min_bpm: f32, max_bpm: f32) -&gt; Self {&#10;            Self {&#10;                min_bpm,&#10;                max_bpm,&#10;                history: Vec::new(),&#10;                history_size: 10,&#10;            }&#10;        }&#10;&#10;        /// Estime le BPM à partir du vecteur d'autocorrélation&#10;        pub fn estimate(&amp;mut self, acf: &amp;[f32], odf_sample_rate: f32) -&gt; Option&lt;f32&gt; {&#10;            // Conversion BPM en plage de lags&#10;            let max_period_s = 60.0 / self.min_bpm;&#10;            let min_period_s = 60.0 / self.max_bpm;&#10;            let min_lag = (min_period_s * odf_sample_rate).round() as usize;&#10;            let max_lag = (max_period_s * odf_sample_rate).round() as usize;&#10;&#10;            if max_lag &gt;= acf.len() || min_lag &gt;= max_lag {&#10;                return None;&#10;            }&#10;&#10;            // Recherche du pic maximum dans la plage de lags&#10;            let search_range = &amp;acf[min_lag..=max_lag.min(acf.len() - 1)];&#10;            let (peak_local_idx, &amp;peak_value) = search_range&#10;                .iter()&#10;                .enumerate()&#10;                .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))?;&#10;&#10;            // Vérification de la qualité du pic (seuil minimal)&#10;            if peak_value &lt; 0.1 {&#10;                return None;&#10;            }&#10;&#10;            let peak_lag = min_lag + peak_local_idx;&#10;&#10;            // Conversion lag -&gt; BPM&#10;            let bpm = (odf_sample_rate * 60.0) / peak_lag as f32;&#10;&#10;            // Stabilisation avec médiane mobile&#10;            self.history.push(bpm);&#10;            if self.history.len() &gt; self.history_size {&#10;                self.history.remove(0);&#10;            }&#10;&#10;            // Calcul de la médiane&#10;            let mut sorted_history = self.history.clone();&#10;            sorted_history.sort_by(|a, b| a.partial_cmp(b).unwrap());&#10;            let median_bpm = sorted_history[sorted_history.len() / 2];&#10;&#10;            Some(median_bpm)&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Programme Principal&#10;// ====================&#10;fn main() -&gt; Result&lt;()&gt; {&#10;    let args = Args::parse();&#10;&#10;    println!(&quot;Chargement du fichier audio: {:?}&quot;, args.file_path);&#10;&#10;    // 1. Décodage et prétraitement&#10;    const TARGET_SR: u32 = 44100;&#10;    let samples = decoder::decode_to_mono(&amp;args.file_path, TARGET_SR)?;&#10;    println!(&quot;Audio chargé: {} échantillons à {} Hz&quot;, samples.len(), TARGET_SR);&#10;&#10;    // 2. Génération de l'ODF&#10;    const FRAME_SIZE: usize = 2048;&#10;    const HOP_SIZE: usize = 512;&#10;&#10;    let odf_gen = odf::OdfGenerator::new(FRAME_SIZE, HOP_SIZE);&#10;    let odf_signal = odf_gen.generate(&amp;samples);&#10;&#10;    let odf_sample_rate = TARGET_SR as f32 / HOP_SIZE as f32;&#10;    println!(&quot;ODF générée: {} valeurs à {:.2} Hz&quot;, odf_signal.len(), odf_sample_rate);&#10;&#10;    // 3. Analyse par autocorrélation&#10;    // Fenêtre de 3 secondes pour l'analyse&#10;    let acf_window_size = (3.0 * odf_sample_rate) as usize;&#10;    let acf_analyzer = acf::AcfAnalyzer::new(acf_window_size);&#10;&#10;    // 4. Estimation du BPM&#10;    let mut bpm_estimator = estimator::BpmEstimator::new(args.min_bpm, args.max_bpm);&#10;&#10;    // Analyse sur plusieurs fenêtres pour plus de robustesse&#10;    let analysis_hop = (odf_sample_rate as usize) / 2; // Analyse toutes les 0.5 secondes&#10;    let mut final_bpm = None;&#10;&#10;    for window_start in (0..odf_signal.len()).step_by(analysis_hop) {&#10;        let window_end = (window_start + acf_window_size).min(odf_signal.len());&#10;        if window_end - window_start &lt; acf_window_size / 2 {&#10;            break; // Fenêtre trop petite&#10;        }&#10;&#10;        let acf = acf_analyzer.analyze(&amp;odf_signal[..window_end]);&#10;        if let Some(bpm) = bpm_estimator.estimate(&amp;acf, odf_sample_rate) {&#10;            final_bpm = Some(bpm);&#10;        }&#10;    }&#10;&#10;    // Affichage du résultat&#10;    match final_bpm {&#10;        Some(bpm) =&gt; println!(&quot;BPM: {:.1}&quot;, bpm),&#10;        None =&gt; eprintln!(&quot;Impossible de détecter le BPM&quot;),&#10;    }&#10;&#10;    Ok(())&#10;}" />
              <option name="updatedContent" value="use anyhow::{Context, Result};&#10;use clap::Parser;&#10;use hound::{SampleFormat, WavReader};&#10;use num_complex::Complex;&#10;use rubato::{FftFixedIn, Resampler};&#10;use rustfft::FftPlanner;&#10;use std::path::PathBuf;&#10;&#10;/// Programme de détection de BPM utilisant l'autocorrélation et le flux spectral médian&#10;#[derive(Parser, Debug)]&#10;#[command(author, version, about, long_about = None)]&#10;struct Args {&#10;    /// Chemin vers le fichier WAV à analyser&#10;    #[arg()]&#10;    file_path: PathBuf,&#10;&#10;    /// BPM minimum à rechercher&#10;    #[arg(long, default_value_t = 60.0)]&#10;    min_bpm: f32,&#10;&#10;    /// BPM maximum à rechercher&#10;    #[arg(long, default_value_t = 180.0)]&#10;    max_bpm: f32,&#10;}&#10;&#10;// ====================&#10;// Module Decoder&#10;// ====================&#10;mod decoder {&#10;    use super::*;&#10;&#10;    /// Charge et décode un fichier WAV en mono avec rééchantillonnage à 44100 Hz&#10;    pub fn decode_to_mono(path: &amp;PathBuf, target_sr: u32) -&gt; Result&lt;Vec&lt;f32&gt;&gt; {&#10;        let mut reader = WavReader::open(path)&#10;            .with_context(|| format!(&quot;Impossible d'ouvrir le fichier {:?}&quot;, path))?;&#10;&#10;        let spec = reader.spec();&#10;        let channels = spec.channels as usize;&#10;        let source_sr = spec.sample_rate;&#10;&#10;        // Lecture des échantillons&#10;        let samples: Vec&lt;f32&gt; = match spec.sample_format {&#10;            SampleFormat::Float =&gt; {&#10;                reader.samples::&lt;f32&gt;()&#10;                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()&#10;                    .context(&quot;Erreur lors de la lecture des échantillons&quot;)?&#10;            }&#10;            SampleFormat::Int =&gt; {&#10;                let bit_depth = spec.bits_per_sample;&#10;                let max_val = (1 &lt;&lt; (bit_depth - 1)) as f32;&#10;                reader.samples::&lt;i32&gt;()&#10;                    .map(|s| s.map(|v| v as f32 / max_val))&#10;                    .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()&#10;                    .context(&quot;Erreur lors de la conversion des échantillons&quot;)?&#10;            }&#10;        };&#10;&#10;        // Conversion en mono&#10;        let mono_samples: Vec&lt;f32&gt; = if channels &gt; 1 {&#10;            samples.chunks(channels)&#10;                .map(|frame| frame.iter().sum::&lt;f32&gt;() / channels as f32)&#10;                .collect()&#10;        } else {&#10;            samples&#10;        };&#10;&#10;        // Rééchantillonnage si nécessaire&#10;        if source_sr != target_sr {&#10;            resample(&amp;mono_samples, source_sr, target_sr)&#10;        } else {&#10;            Ok(mono_samples)&#10;        }&#10;    }&#10;&#10;    /// Rééchantillonne le signal audio à la fréquence cible&#10;    fn resample(samples: &amp;[f32], source_sr: u32, target_sr: u32) -&gt; Result&lt;Vec&lt;f32&gt;&gt; {&#10;        let mut resampler = FftFixedIn::&lt;f32&gt;::new(&#10;            source_sr as usize,&#10;            target_sr as usize,&#10;            1024,&#10;            1,&#10;            1,&#10;        ).context(&quot;Erreur lors de l'initialisation du resampler&quot;)?;&#10;&#10;        let mut output = vec![vec![0.0f32; resampler.output_frames_max()]; 1];&#10;        let mut resampled = Vec::new();&#10;&#10;        // Traitement par chunks&#10;        for chunk in samples.chunks(1024) {&#10;            let input = vec![chunk.to_vec()];&#10;            let (_, out_len) = resampler.process_into_buffer(&amp;input, &amp;mut output, None)&#10;                .context(&quot;Erreur lors du rééchantillonnage&quot;)?;&#10;            resampled.extend_from_slice(&amp;output[0][..out_len]);&#10;        }&#10;&#10;        Ok(resampled)&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module ODF (Onset Detection Function)&#10;// ====================&#10;mod odf {&#10;    use super::*;&#10;&#10;    /// Paramètres pour la génération de l'ODF&#10;    pub struct OdfGenerator {&#10;        pub frame_size: usize,&#10;        pub hop_size: usize,&#10;    }&#10;&#10;    impl OdfGenerator {&#10;        pub fn new(frame_size: usize, hop_size: usize) -&gt; Self {&#10;            Self { frame_size, hop_size }&#10;        }&#10;&#10;        /// Génère l'ODF en utilisant le flux spectral agrégé par la médiane&#10;        pub fn generate(&amp;self, samples: &amp;[f32]) -&gt; Vec&lt;f32&gt; {&#10;            let mut planner = FftPlanner::&lt;f32&gt;::new();&#10;            let fft = planner.plan_fft_forward(self.frame_size);&#10;&#10;            // Création de la fenêtre de Hann manuellement&#10;            let window: Vec&lt;f32&gt; = (0..self.frame_size)&#10;                .map(|i| {&#10;                    let t = i as f32 / (self.frame_size - 1) as f32;&#10;                    0.5 * (1.0 - (2.0 * std::f32::consts::PI * t).cos())&#10;                })&#10;                .collect();&#10;&#10;            let mut odf = Vec::new();&#10;            let mut prev_magnitudes = vec![0.0; self.frame_size / 2 + 1];&#10;&#10;            // Calcul du nombre de frames&#10;            let num_frames = (samples.len() - self.frame_size) / self.hop_size + 1;&#10;&#10;            for frame_idx in 0..num_frames {&#10;                let start = frame_idx * self.hop_size;&#10;                let end = start + self.frame_size;&#10;&#10;                if end &gt; samples.len() {&#10;                    break;&#10;                }&#10;&#10;                // Application de la fenêtre et préparation pour FFT&#10;                let mut buffer: Vec&lt;Complex&lt;f32&gt;&gt; = samples[start..end]&#10;                    .iter()&#10;                    .zip(window.iter())&#10;                    .map(|(s, w)| Complex::new(s * w, 0.0))&#10;                    .collect();&#10;&#10;                // FFT&#10;                fft.process(&amp;mut buffer);&#10;&#10;                // Calcul des magnitudes (seulement la moitié positive du spectre)&#10;                let magnitudes: Vec&lt;f32&gt; = buffer[..self.frame_size / 2 + 1]&#10;                    .iter()&#10;                    .map(|c| (c.re * c.re + c.im * c.im).sqrt())&#10;                    .collect();&#10;&#10;                // Calcul du flux spectral avec agrégation par médiane&#10;                let mut spectral_diffs: Vec&lt;f32&gt; = magnitudes&#10;                    .iter()&#10;                    .zip(prev_magnitudes.iter())&#10;                    .map(|(current, prev)| {&#10;                        // Passage en échelle logarithmique pour plus de robustesse&#10;                        let log_current = (current + 1e-10_f32).ln();&#10;                        let log_prev = (prev + 1e-10_f32).ln();&#10;                        (log_current - log_prev).max(0.0)  // Redressement demi-onde&#10;                    })&#10;                    .collect();&#10;&#10;                // Calcul de la médiane&#10;                if !spectral_diffs.is_empty() {&#10;                    spectral_diffs.sort_by(|a, b| a.partial_cmp(b).unwrap());&#10;                    let median_idx = spectral_diffs.len() / 2;&#10;                    odf.push(spectral_diffs[median_idx]);&#10;                } else {&#10;                    odf.push(0.0);&#10;                }&#10;&#10;                prev_magnitudes = magnitudes;&#10;            }&#10;&#10;            odf&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module ACF (Autocorrelation Function)&#10;// ====================&#10;mod acf {&#10;    use super::*;&#10;&#10;    /// Analyseur d'autocorrélation utilisant le théorème de Wiener-Khinchin&#10;    pub struct AcfAnalyzer {&#10;        pub window_size: usize,&#10;    }&#10;&#10;    impl AcfAnalyzer {&#10;        pub fn new(window_size: usize) -&gt; Self {&#10;            Self { window_size }&#10;        }&#10;&#10;        /// Calcule l'autocorrélation à court terme via FFT (Wiener-Khinchin)&#10;        pub fn analyze(&amp;self, odf_buffer: &amp;[f32]) -&gt; Vec&lt;f32&gt; {&#10;            // Prendre les dernières valeurs selon la taille de fenêtre&#10;            let start = odf_buffer.len().saturating_sub(self.window_size);&#10;            let window = &amp;odf_buffer[start..];&#10;&#10;            // Zero-padding pour obtenir une corrélation linéaire correcte&#10;            let fft_len = (window.len() * 2).next_power_of_two();&#10;&#10;            let mut planner = FftPlanner::&lt;f32&gt;::new();&#10;            let fft = planner.plan_fft_forward(fft_len);&#10;            let ifft = planner.plan_fft_inverse(fft_len);&#10;&#10;            // Préparation du buffer avec zero-padding&#10;            let mut buffer: Vec&lt;Complex&lt;f32&gt;&gt; = window&#10;                .iter()&#10;                .map(|&amp;s| Complex::new(s, 0.0))&#10;                .chain(std::iter::repeat(Complex::new(0.0, 0.0)))&#10;                .take(fft_len)&#10;                .collect();&#10;&#10;            // 1. Forward FFT&#10;            fft.process(&amp;mut buffer);&#10;&#10;            // 2. Power spectrum (|X(f)|²)&#10;            for c in buffer.iter_mut() {&#10;                let power = c.re * c.re + c.im * c.im;&#10;                *c = Complex::new(power, 0.0);&#10;            }&#10;&#10;            // 3. Inverse FFT&#10;            ifft.process(&amp;mut buffer);&#10;&#10;            // 4. Normalisation et extraction de la partie réelle&#10;            let scale = 1.0 / fft_len as f32;&#10;            buffer.iter()&#10;                .map(|c| c.re * scale)&#10;                .take(window.len())  // Ne garder que la partie utile&#10;                .collect()&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Module Estimator&#10;// ====================&#10;mod estimator {&#10;    /// Estimateur de BPM avec stabilisation&#10;    pub struct BpmEstimator {&#10;        pub min_bpm: f32,&#10;        pub max_bpm: f32,&#10;        pub history: Vec&lt;f32&gt;,&#10;        pub history_size: usize,&#10;    }&#10;&#10;    impl BpmEstimator {&#10;        pub fn new(min_bpm: f32, max_bpm: f32) -&gt; Self {&#10;            Self {&#10;                min_bpm,&#10;                max_bpm,&#10;                history: Vec::new(),&#10;                history_size: 10,&#10;            }&#10;        }&#10;&#10;        /// Estime le BPM à partir du vecteur d'autocorrélation&#10;        pub fn estimate(&amp;mut self, acf: &amp;[f32], odf_sample_rate: f32) -&gt; Option&lt;f32&gt; {&#10;            // Conversion BPM en plage de lags&#10;            let max_period_s = 60.0 / self.min_bpm;&#10;            let min_period_s = 60.0 / self.max_bpm;&#10;            let min_lag = (min_period_s * odf_sample_rate).round() as usize;&#10;            let max_lag = (max_period_s * odf_sample_rate).round() as usize;&#10;&#10;            if max_lag &gt;= acf.len() || min_lag &gt;= max_lag {&#10;                return None;&#10;            }&#10;&#10;            // Recherche du pic maximum dans la plage de lags&#10;            let search_range = &amp;acf[min_lag..=max_lag.min(acf.len() - 1)];&#10;            let (peak_local_idx, &amp;peak_value) = search_range&#10;                .iter()&#10;                .enumerate()&#10;                .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))?;&#10;&#10;            // Vérification de la qualité du pic (seuil minimal)&#10;            if peak_value &lt; 0.1 {&#10;                return None;&#10;            }&#10;&#10;            let peak_lag = min_lag + peak_local_idx;&#10;&#10;            // Conversion lag -&gt; BPM&#10;            let bpm = (odf_sample_rate * 60.0) / peak_lag as f32;&#10;&#10;            // Stabilisation avec médiane mobile&#10;            self.history.push(bpm);&#10;            if self.history.len() &gt; self.history_size {&#10;                self.history.remove(0);&#10;            }&#10;&#10;            // Calcul de la médiane&#10;            let mut sorted_history = self.history.clone();&#10;            sorted_history.sort_by(|a, b| a.partial_cmp(b).unwrap());&#10;            let median_bpm = sorted_history[sorted_history.len() / 2];&#10;&#10;            Some(median_bpm)&#10;        }&#10;    }&#10;}&#10;&#10;// ====================&#10;// Programme Principal&#10;// ====================&#10;fn main() -&gt; Result&lt;()&gt; {&#10;    let args = Args::parse();&#10;&#10;    println!(&quot;Chargement du fichier audio: {:?}&quot;, args.file_path);&#10;&#10;    // 1. Décodage et prétraitement&#10;    const TARGET_SR: u32 = 44100;&#10;    let samples = decoder::decode_to_mono(&amp;args.file_path, TARGET_SR)?;&#10;    println!(&quot;Audio chargé: {} échantillons à {} Hz&quot;, samples.len(), TARGET_SR);&#10;&#10;    // 2. Génération de l'ODF&#10;    const FRAME_SIZE: usize = 2048;&#10;    const HOP_SIZE: usize = 512;&#10;&#10;    let odf_gen = odf::OdfGenerator::new(FRAME_SIZE, HOP_SIZE);&#10;    let odf_signal = odf_gen.generate(&amp;samples);&#10;&#10;    let odf_sample_rate = TARGET_SR as f32 / HOP_SIZE as f32;&#10;    println!(&quot;ODF générée: {} valeurs à {:.2} Hz&quot;, odf_signal.len(), odf_sample_rate);&#10;&#10;    // 3. Analyse par autocorrélation&#10;    // Fenêtre de 3 secondes pour l'analyse&#10;    let acf_window_size = (3.0 * odf_sample_rate) as usize;&#10;    let acf_analyzer = acf::AcfAnalyzer::new(acf_window_size);&#10;&#10;    // 4. Estimation du BPM&#10;    let mut bpm_estimator = estimator::BpmEstimator::new(args.min_bpm, args.max_bpm);&#10;&#10;    // Analyse sur plusieurs fenêtres pour plus de robustesse&#10;    let analysis_hop = (odf_sample_rate as usize) / 2; // Analyse toutes les 0.5 secondes&#10;    let mut final_bpm = None;&#10;&#10;    for window_start in (0..odf_signal.len()).step_by(analysis_hop) {&#10;        let window_end = (window_start + acf_window_size).min(odf_signal.len());&#10;        if window_end - window_start &lt; acf_window_size / 2 {&#10;            break; // Fenêtre trop petite&#10;        }&#10;&#10;        let acf = acf_analyzer.analyze(&amp;odf_signal[..window_end]);&#10;        if let Some(bpm) = bpm_estimator.estimate(&amp;acf, odf_sample_rate) {&#10;            final_bpm = Some(bpm);&#10;        }&#10;    }&#10;&#10;    // Affichage du résultat&#10;    match final_bpm {&#10;        Some(bpm) =&gt; println!(&quot;BPM: {:.1}&quot;, bpm),&#10;        None =&gt; eprintln!(&quot;Impossible de détecter le BPM&quot;),&#10;    }&#10;&#10;    Ok(())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>